const express = require("express")
const multer = require("multer")
const { spawnSync } = require('child_process');
const path = require("path")
const fs = require("fs")
const mongoose = require("mongoose")
const Report = require("../models/Report")
const Company = require("../models/Company")
const {re} = require("mathjs");
const {authenticateToken} = require("../middleware/tokenValidation");
const {catchAsync} = require("../middleware/errorHandling");

const router = express.Router()
router.use(express.json())



function saveReportToDb(jsonData) {
    /**
     * Takes an array of json report objects and iteratively saves them into the database.
     *
     * @param {Array} jsonData - An array of json report objects
     * @returns {void}
     */

    Array.from(jsonData).forEach(async (jsonReport)=>{
        const newReport = new Report(jsonReport)
        await newReport.save()
    })
}

async function checkReportExistence(jsonData) {
    /**
     * Takes a report json object as argument and searches the database for a report by the same company
     * from the same period. Returns the result as a boolean.
     *
     * @param {Object} jsonData - A report json object
     * @returns {Boolean} True, if this report already exists, false otherwise
     */

    const foundReport = await Report.findOne({company_id: jsonData.company_id, period: jsonData.period})
    if (foundReport) {
        return foundReport._id
    }
    return false
}

async function setCompanyIdForReports(jsonData) {
    /**
     * The xlsx-reader sets the company_id attribute to the name of the company,
     * because it doesn't have access to the database. This function iteratively substitutes the name of the company
     * with the autogenerated MongoDB-ID of the corresponding company by searching said company in the database.
     *
     * @param {Array} jsonData - An array of json report objects
     * @returns {Array} An array with the modified report objects
     */

    /* The iteration has to be done with Promise.all() and map() because .forEach() doesn't wait for async returns
    inside the iteration */
    const reports = await Promise.all(jsonData.map(async (report)=>{
        const found_company = await Company.findOne({name: report.company_id})
        if (found_company) { // The reports are only modified if their company was found in the DB
            report.company_id = found_company._id
            return report
        } else {
            return null // Insert null into the reports array to indicate a failed modification
        }
    }))

    if (reports.includes(null)) {
        // If the modification process has failed for the reports, return false
        return false;
    }

    return reports

}

function validatePythonResult(result) {
    /**
     * Iterates over the result from the python script and checks, if one of the reports contained
     * invalid data. If yes, an error message is returned.
     *
     * @param {String} result - The stdout result from the python script
     * @returns {String|void} An error message if a report is invalid or nothing
     */
    let counter = 1
    let errorMessage = undefined
    JSON.parse(result).forEach(reportJson=>{
        if (reportJson === "report contains invalid data") {
            // If one of the reports in the xlsx file is invalid, the position of it and an error message is returned
            errorMessage = `${counter}. report contains invalid data.`
            // Second report will return "2. report contains invalid data"
        }
        counter += 1
    })
    return errorMessage
}


function cleanUploadDirectory() {
    /**
     * Iterates over all files inside the upload directory and deletes them.
     *
     * @returns {void}
     */

    // Source: https://hayageek.com/remove-all-files-from-directory-in-nodejs/
    const uploadDir = path.join(__dirname, "../../uploads")
    const files = fs.readdirSync(uploadDir);

    for (const file of files) {
        const filePath = path.join(uploadDir, file);
        fs.unlinkSync(filePath);
    }
}


// Ensure 'uploads' directory exists
const uploadDir = path.join(__dirname, "../../uploads");
if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
}

// Multer configuration
// Source: https://dev.to/malikbilal111/building-a-file-upload-rest-api-with-nodejs-and-express-56l2
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
        cb(null, Date.now() + '-' + file.originalname);
    },
});

const upload = multer({ storage });


router.post("/", authenticateToken, upload.single("file"), catchAsync(async (req, res)=>{
    // File must be sent using multipart/form-data with the key "file" in the form
    if (!req.file) {
        return res.status(400).json({message: "no file provided"})
    }

    // Check if the uploaded file is actually an Excel spreadsheet
    const fileType = req.file.mimetype
    if (fileType !== "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") {
        cleanUploadDirectory()
        return res.status(400).json({message: "files must be be of type .xlsx"})
    }

    const fileName = req.file.filename
    const filePath = path.join(__dirname, '../../uploads', fileName);
    const scriptPath = path.resolve(__dirname, '../data_processing/xlsx_reader.py');

    // Create a python subprocess to call the xlsx reader script
    const pythonProcess = await spawnSync('/usr/bin/python3', [
        scriptPath,
        'main',
        filePath
    ]);

    const result = pythonProcess.stdout?.toString()?.trim();
    const error = pythonProcess.stderr?.toString()?.trim();

    if (error) {
        // If the python script has encountered an error that was caused by an invalid file format
        if (error.includes("TypeError")) {
            return res.status(400).json(
                {message: "The provided file could not be processed. Please verify its integrity."})
        }

        // If the python script has encountered an error that wasn't caused by a faulty input:
        console.error("The Python process has encountered an error: ", error)
        return res.status(500).json(
            {message: "An error has occurred during processing of the file."})
    }

    const reportJson = JSON.parse(result)

    // The python result is searched for error messages about invalid data inside the xlsx files
    const errorMessage = validatePythonResult(result)
    if (errorMessage) {
        // If one or more reports in the xlsx file are invalid, none of them are saved to the database and 400 is returned
        return res.status(400).json({message: errorMessage})
    }

    // The companies that the reports belong to are searched and their ID is written into the report objects
    const modifiedReportJson = await setCompanyIdForReports(reportJson)

    if (!modifiedReportJson) {
        return res.status(404).json({message: `company not found`})
    }

    // check if reports with the same period and company already exist in the database or in the same file
    const periods = []
    for (let i = 0; i < modifiedReportJson.length; i++) {
        const report = modifiedReportJson[i]
        const foundReportId = await checkReportExistence(report)
        if (foundReportId !== false) {
            // Delete an already existing report for this period so that it can be substituted
            await Report.deleteOne({_id: new mongoose.Types.ObjectId(foundReportId)})
        }
        if (periods.includes(report.period)) { // Check if a report with the same period exists in the uploaded file
            return res.status(400).json({message: `file contains duplicate reports for period ${report.period}`})
        }
        periods.push(report.period) // Add the period of the current iteration to all periods for duplicate validation
    }

    saveReportToDb(modifiedReportJson)

    const reportCount = modifiedReportJson.length

    res.status(201).json({"message": `successfully saved ${reportCount} reports`})

    cleanUploadDirectory()

}))

module.exports = router